# Tasks

1. * Stop request:
   ```js
   #search slow requests
   db.currentOp(
      {
        "active" : true,
        "secs_running" : { "$gt" : 180 },
      }
   )
   #kill slow request
   db.killOp(<opid>)
   ```
   * Для начала необходимо проанализировать эти долгие запросы и, в последствии, их оптимизировать. Или настроить индексы. Так же, как вариант, чтобы не приходилось вручную искать зависшые долгие запросы можно настроить таймер на максимально возможное время выполнения запросов - `$maxTimeMS`.
2. Скорее всего дело в том, что закончилась выделенная память. (Рост новых значений по отношению к тем, что должны быть очищены = рост размера хранилища.)
3. Если ошибки подобного вида стали появляться регулярно, а сеть проверена и гарантированно работает, то скорее всего дело в том, что происходит выборка слишком большого количества данных и mysql не успевает их обработать до истечения `net_read_timeout`. Можно увеличить данное значение в два раза (с 30 до 60 секунд), как это рекомендует документация, однако сначала лучше всё-таки попытаться оптимизировать запросы (с помощью индексов, например).
4. OOM - out of memory (нехватка памяти). OOM-killer - встроенный в систему механизм защиты от переполнения памяти. Скорее всего PostreSQL "съел" всю доступную память, и, чтобы предотвратить падение сервера, данный механизм завершил работу (или перезапустил) сервис субд. Решений данной проблемы может быть несколько:
   * Ограничить максимально доступную для субд память;
   * Распределить нагрузку, оставив работать на сервере только СУБД;
   * Увеличить доступные серверу ресурсы.
